--[[
	Keys:
	- F0 = Register A 
	- F1 = Register B 
	- F2 = Register C 
	- F3 = Register D 
	- F4 = Register E
	- F5 = Register F 
	- F6 = Register G
	- F7 = Register H
	- F8 = Top Stack
	- F9 = Push to Top Stack
	- FA = Next Byte
	- FB = Previous Byte 
	- FC = Current Stack Position
	- FD = Specific Byte Address 
	- FE = Specific Short Address
	
	Instructions:
		- Utilities
		- 00 											- Exit
		- 01 [key] (byte (byte)) [byte]					- Load to [byte] to [key]
		- 02 [key] (byte (byte)) [key] (byte (byte))	- Pass to [Stack Position]
		- 03 [key] (byte (byte)) [key] (byte (byte))	- Swap Values
		- 04 [key] (byte (byte))						- Jump to
		- 05 [byte]										- Output as integer 
		- 06 [byte]										- Output as char 
		- 07 [key] (byte, (byte))						- Output as integer from addr 
		- 08 [key] (byte, (byte))						- Output as char
		- 0A [key] (byte, (byte))						- Read input as number 
		- 0B [key] (byte, (byte))						- Read input as character 
		- 0C [key] (byte, (byte))						- Read input as hex
		
		- Bitwise
		- 11 [key] (byte (byte)) [byte]					- AND
		- 12 [key] (byte (byte)) [byte]					- OR
		- 13 [key] (byte (byte)) [byte]					- XOR 
		- 14 [key] (byte (byte))						- NOT
		- 15 [key] (byte (byte)) [byte]					- LSHIFT 
		- 16 [key] (byte (byte)) [byte]					- RSHIFT 
		- 17 [key] (byte (byte)) [byte]					- ROL
		- 18 [key] (byte (byte)) [byte]					- ROR 
		
		- Bitwise key by key 
		- 21 [key] (byte (byte)) [key] (byte (byte))	- AND
		- 22 [key] (byte (byte)) [key] (byte (byte))	- OR
		- 23 [key] (byte (byte)) [key] (byte (byte))	- XOR 
		- 24 [key] (byte (byte))						- NOT
		- 25 [key] (byte (byte)) [key] (byte (byte))	- LSHIFT 
		- 26 [key] (byte (byte)) [key] (byte (byte))	- RSHIFT 
		- 27 [key] (byte (byte)) [key] (byte (byte))	- ROL
		- 28 [key] (byte (byte)) [key] (byte (byte))	- ROR 
		
		- Arithmetic
		- 31 [key] (byte (byte)) [byte]					- ADD
		- 32 [key] (byte (byte)) [byte]					- SUB
		
		- Arithmetic Key to Key
		- 41 [key] (byte (byte)) [key] (byte (byte))	- ADD 
		- 42 [key] (byte (byte)) [key] (byte (byte))	- SUB
		
		- Conditional
		- 51 [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) - IF (key) JMP (key) ELSE JMP (key)
		- 52 [key] (byte (byte)) [key] (byte (byte)) [byte] [byte]		 - IF (key) SET (key) = [byte] else [byte]
		- 53 [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) 
					- IF (key) SET (key) = (key) else (key)
		
		- Comparator (A2B)
		- 61 [key] (byte (byte)) [key] (byte (byte)) [byte] - EQUAL
		- 62 [key] (byte (byte)) [key] (byte (byte)) [byte] - NOT EQUAL 
		- 63 [key] (byte (byte)) [key] (byte (byte)) [byte] - GREATER THAN
		- 64 [key] (byte (byte)) [key] (byte (byte)) [byte] - LESS THAN 
		- 65 [key] (byte (byte)) [key] (byte (byte)) [byte] - GREATER THAN OR EQUAL 
		- 66 [key] (byte (byte)) [key] (byte (byte)) [byte] - LESS THAN OR EQUAL
		
		- Comparator (A2A)
		- 71 [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) - EQUAL
		- 72 [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) - NOT EQUAL 
		- 73 [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) - GREATER THAN
		- 74 [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) - LESS THAN 
		- 75 [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) - GREATER THAN OR EQUAL 
		- 76 [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) - LESS THAN OR EQUAL
		
		- Push/Pop
		- 91 [byte]	- Push [byte] to stack 
		- 92  - Pop from stack
		- 93 [key] (byte (byte)) - Push value of address to stack 
		- 94 [key] (byte (byte)) - Pop value from stack then put it into the address
]]

local DEBUG_MODE = false

local printx = print 
print = function (...)
	if DEBUG_MODE then printx(...) end
end 
-- sub-byte bitwise
local AND4 = {
[0]=0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1,
	0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2,
	0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3,
	0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x4, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x4, 0x4,
	0x0, 0x1, 0x0, 0x1, 0x4, 0x5, 0x4, 0x5, 0x0, 0x1, 0x0, 0x1, 0x4, 0x5, 0x4, 0x5,
	0x0, 0x0, 0x2, 0x2, 0x4, 0x4, 0x6, 0x6, 0x0, 0x0, 0x2, 0x2, 0x4, 0x4, 0x6, 0x6,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x8, 0x9, 0x8, 0x9, 0x8, 0x9, 0x8, 0x9,
	0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x8, 0x8, 0xa, 0xa, 0x8, 0x8, 0xa, 0xa,
	0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3, 0x8, 0x9, 0xa, 0xb, 0x8, 0x9, 0xa, 0xb,
	0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x4, 0x4, 0x8, 0x8, 0x8, 0x8, 0xc, 0xc, 0xc, 0xc,
	0x0, 0x1, 0x0, 0x1, 0x4, 0x5, 0x4, 0x5, 0x8, 0x9, 0x8, 0x9, 0xc, 0xd, 0xc, 0xd,
	0x0, 0x0, 0x2, 0x2, 0x4, 0x4, 0x6, 0x6, 0x8, 0x8, 0xa, 0xa, 0xc, 0xc, 0xe, 0xe,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
}
local OR4 = {
[0]=0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x1, 0x1, 0x3, 0x3, 0x5, 0x5, 0x7, 0x7, 0x9, 0x9, 0xb, 0xb, 0xd, 0xd, 0xf, 0xf,
	0x2, 0x3, 0x2, 0x3, 0x6, 0x7, 0x6, 0x7, 0xa, 0xb, 0xa, 0xb, 0xe, 0xf, 0xe, 0xf,
	0x3, 0x3, 0x3, 0x3, 0x7, 0x7, 0x7, 0x7, 0xb, 0xb, 0xb, 0xb, 0xf, 0xf, 0xf, 0xf,
	0x4, 0x5, 0x6, 0x7, 0x4, 0x5, 0x6, 0x7, 0xc, 0xd, 0xe, 0xf, 0xc, 0xd, 0xe, 0xf,
	0x5, 0x5, 0x7, 0x7, 0x5, 0x5, 0x7, 0x7, 0xd, 0xd, 0xf, 0xf, 0xd, 0xd, 0xf, 0xf,
	0x6, 0x7, 0x6, 0x7, 0x6, 0x7, 0x6, 0x7, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x9, 0x9, 0xb, 0xb, 0xd, 0xd, 0xf, 0xf, 0x9, 0x9, 0xb, 0xb, 0xd, 0xd, 0xf, 0xf,
	0xa, 0xb, 0xa, 0xb, 0xe, 0xf, 0xe, 0xf, 0xa, 0xb, 0xa, 0xb, 0xe, 0xf, 0xe, 0xf,
	0xb, 0xb, 0xb, 0xb, 0xf, 0xf, 0xf, 0xf, 0xb, 0xb, 0xb, 0xb, 0xf, 0xf, 0xf, 0xf,
	0xc, 0xd, 0xe, 0xf, 0xc, 0xd, 0xe, 0xf, 0xc, 0xd, 0xe, 0xf, 0xc, 0xd, 0xe, 0xf,
	0xd, 0xd, 0xf, 0xf, 0xd, 0xd, 0xf, 0xf, 0xd, 0xd, 0xf, 0xf, 0xd, 0xd, 0xf, 0xf,
	0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
}
local XOR4 = {
[0]=0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6, 0x9, 0x8, 0xb, 0xa, 0xd, 0xc, 0xf, 0xe,
	0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5, 0xa, 0xb, 0x8, 0x9, 0xe, 0xf, 0xc, 0xd,
	0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4, 0xb, 0xa, 0x9, 0x8, 0xf, 0xe, 0xd, 0xc,
	0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3, 0xc, 0xd, 0xe, 0xf, 0x8, 0x9, 0xa, 0xb,
	0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2, 0xd, 0xc, 0xf, 0xe, 0x9, 0x8, 0xb, 0xa,
	0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1, 0xe, 0xf, 0xc, 0xd, 0xa, 0xb, 0x8, 0x9,
	0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0, 0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9, 0x8,
	0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
	0x9, 0x8, 0xb, 0xa, 0xd, 0xc, 0xf, 0xe, 0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6,
	0xa, 0xb, 0x8, 0x9, 0xe, 0xf, 0xc, 0xd, 0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5,
	0xb, 0xa, 0x9, 0x8, 0xf, 0xe, 0xd, 0xc, 0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4,
	0xc, 0xd, 0xe, 0xf, 0x8, 0x9, 0xa, 0xb, 0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3,
	0xd, 0xc, 0xf, 0xe, 0x9, 0x8, 0xb, 0xa, 0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2,
	0xe, 0xf, 0xc, 0xd, 0xa, 0xb, 0x8, 0x9, 0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1,
	0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0,
}
local RIGHT = {
[0]=0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
}
local LEFT = {
[0]=0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
}

local floor = math.floor 


--[[
	Memoization
]]--
local mem_AND = {}
local mem_OR = {}
local mem_XOR = {}
local mem_LSHIFT = {}
local mem_RSHIFT = {}
local mem_ROL = {}
local mem_ROR = {}

local function bw8(a, b, op, mem)
	local key = a*256 + b
	local result = mem[key] or mem[b*256 + a]
	if(not result) then 
		local la, ra = LEFT[a], RIGHT[a]
		local lb, rb = LEFT[b], RIGHT[b]
		local lr, rr = op[la*16 + lb], op[ra*16 + rb]
		
		result = lr*16 + rr
		
		mem[key] = result 
	end 
	return result
end 

local function AND(a, b)
	print("Call:", "AND", "a = "..a, "b = "..b)
	return bw8(a, b, AND4, mem_AND)
end

local function OR(a, b)
	print("Call:", "OR", "a = "..a, "b = "..b)
	return bw8(a, b, OR4, mem_OR)
end 

local function XOR(a, b)
	print("Call:", "XOR", "a = "..a, "b = "..b)
	return bw8(a, b, XOR4, mem_XOR)
end 

local function NOT(a)
	print("Call:", "NOT", "a = "..a, "b = "..b)
	return 255 - a
end

local function LSHIFT(a, b)
	print("Call:", "LSHIFT", "a = "..a, "b = "..b)
	if(b >= 8) then 
		return 0
	end 
	local key = a*256 + b 
	local result = mem_LSHIFT[key] or mem_LSHIFT[b*256 + a]
	if(not result) then 
		result = a*(2^b)
		mem_LSHIFT[key] = result
	end
	return result 
end

local function RSHIFT(a, b)
	print("Call:", "RSHIFT", "a = "..a, "b = "..b)
	if(b >= 8) then 
		return 0
	end 
	local key = a*256 + b 
	local result = mem_RSHIFT[key] or mem_RSHIFT[b*256 + a]
	if(not result) then 
		result = floor(a/(2^b))
		mem_RSHIFT[key] = result
	end
	return result 
end

local function ROL(a, b)
	print("Call:", "ROL", "a = "..a, "b = "..b)
	b = b % 8
	local key = a*256 + b 
	local result = mem_ROL[key] or mem_ROL[b*256 + a]
	if(not result) then 
		result = OR(LSHIFT(a, b), RSHIFT(a, 8 - b))
		mem_ROL[key] = result
	end
	return result 
end 

local function ROR(a, b)
	print("Call:", "ROR", "a = "..a, "b = "..b)
	b = b % 8
	local key = a*256 + b 
	local result = mem_ROL[key] or mem_ROL[b*256 + a]
	if(not result) then 
		result = OR(RSHIFT(a, b), LSHIFT(a, 8 - b))
		mem_ROL[key] = result
	end
	return result 
end 

local len = string.len 

local COMMENT = "#"


local function validateToken(str)
	return string.match(str, "%x%x")
end

local function parseProgram(program, output)
	program = program:lower()
	local ignore = false 
	
	local count = 1
	for word in program:gmatch("%S+") do 
		if(word == COMMENT) then 
			ignore = not ignore 
		end
		if(not ignore) then 
			if(validateToken(word)) then 
				output[count] = tonumber(string.format("%d", "0x"..word))
				count = count + 1
			else 
				return false
			end
		end 
	end
	
	return true
end 

--[[
	Instructions
]]--
local registers = {
	[0xF0] = "A",
	[0xF1] = "B",
	[0xF2] = "C",
	[0xF3] = "D",
	[0xF4] = "E",
	[0xF5] = "F",
	[0xF6] = "G",
	[0xF7] = "H"
}
local function exitProgram(stack)
	print("Call:", "EXIT")
	stack.exit = true 
end 

local function boundRegister(r)
	if(type(r) == "number") then 
		if(r < 0) then 
			return 0
		end 
		return r 
	end 
	return r or 0
end

local function writeByte(stack, r1, value)
	r1 = boundRegister(r1)
	print("Call:", "writeByte", "register = "..r1, "value = "..string.format("%0.2X", value))
	stack[r1] = (type(value) == "number") and (value % 256) or 0
end 

local function readByte(stack, r)
	print("Call:", "readByte", "register = "..(r or 0), "value = "..string.format("%0.2X", stack[boundRegister(r)] or 0))
	--print("readByte", r, stack[boundRegister(r)] or 0)
	return stack[boundRegister(r)] or 0
end

local function passTo(stack, r1, r2)
	writeByte(stack, r2, readByte(stack, r1))
end 

local function swap(stack, r1, r2)
	r1 = boundRegister(r1)
	r2 = boundRegister(r2)
	stack[r1], stack[r2] = stack[r2], stack[r1]
end 

local function jump(stack, r1)
	stack.pointer = r1
end

local function readNext(stack)
	stack.pointer = stack.pointer + 1
end

local function readCurrentByte(stack)
	return readByte(stack, stack.pointer)
end

local function readNextByte(stack)
	readNext(stack)
	return readCurrentByte(stack)
end

local function readAddress(stack)
	local key = readNextByte(stack)
	local register = registers[key]
	if(register) then 
		return register 
	elseif(key == 0xF8) then 
		return #stack 
	elseif(key == 0xF9) then 
		return #stack + 1
	elseif(key == 0xFA) then 
		return stack.pointer + 1
	elseif(key == 0xFB) then 
		return stack.pointer - 1
	elseif(key == 0xFC) then 
		return stack.pointer
	elseif(key == 0xFD) then 
		return readNextByte(stack)
	elseif(key == 0xFE) then 
		return readNextByte(stack)*0x100 + readNextByte(stack)
	else 
		exitProgram(stack)
	end 
end
	
local function performLoad(stack)
	writeByte(stack, readAddress(stack), readNextByte(stack))
	readNext(stack)
end

local function performPass(stack)
	passTo(stack, readAddress(stack), readAddress(stack))
	readNext(stack)
end

local function performSwap(stack)
	swap(stack, readAddress(stack), readAddress(stack))
	readNext(stack)
end 

local function performJump(stack)
	local addr = readAddress(stack)
	if(type(addr) == "string") then 
		jump(stack, readByte(stack, addr))
	else 
		jump(stack, addr)
	end 
end

local function performAND(stack)
	local addr = readAddress(stack)
	writeByte(stack, addr,  AND(readByte(stack, addr), readNextByte(stack)))
	readNext(stack)
end 

local function performOR(stack)
	local addr = readAddress(stack)
	writeByte(stack, addr,  OR(readByte(stack, addr), readNextByte(stack)))
	readNext(stack)
end

local function performXOR(stack)
	local addr = readAddress(stack)
	writeByte(stack, addr,  XOR(readByte(stack, addr), readNextByte(stack)))
	readNext(stack)
end

local function performNOT(stack)
	local addr = readAddress(stack)
	writeByte(stack, addr,  NOT(readByte(stack, addr)))
	readNext(stack)
end

local function performLSHIFT(stack)
	local addr = readAddress(stack)
	writeByte(stack, addr,  LSHIFT(readByte(stack, addr), readNextByte(stack)))
	readNext(stack)
end

local function performRSHIFT(stack)
	local addr = readAddress(stack)
	writeByte(stack, addr,  RSHIFT(readByte(stack, addr), readNextByte(stack)))
	readNext(stack)
end

local function performROL(stack)
	local addr = readAddress(stack)
	writeByte(stack, addr,  ROL(readByte(stack, addr), readNextByte(stack)))
	readNext(stack)
end

local function performROR(stack)
	local addr = readAddress(stack)
	writeByte(stack, addr,  ROR(readByte(stack, addr), readNextByte(stack)))
	readNext(stack)
end

local function performAND2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	writeByte(stack, addr,  AND(readByte(stack, addr), readByte(stack, addr2)))
	readNext(stack)
end 

local function performOR2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	writeByte(stack, addr,  OR(readByte(stack, addr), readByte(stack, addr2)))
	readNext(stack)
end

local function performXOR2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	writeByte(stack, addr,  XOR(readByte(stack, addr), readByte(stack, addr2)))
	readNext(stack)
end

local function performNOT2(stack)
	local addr = readAddress(stack)
	writeByte(stack, addr, NOT(readByte(stack, addr)))
	readNext(stack)
end

local function performLSHIFT2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	writeByte(stack, addr, LSHIFT(readByte(stack, addr), readByte(stack, addr2)))
	readNext(stack)
end

local function performRSHIFT2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	writeByte(stack, addr, RSHIFT(readByte(stack, addr), readByte(stack, addr2)))
	readNext(stack)
end

local function performROL2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	writeByte(stack, addr, ROL(readByte(stack, addr), readByte(stack, addr2)))
	readNext(stack)
end

local function performROR2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	writeByte(stack, addr, ROR(readByte(stack, addr), readByte(stack, addr2)))
	readNext(stack)
end

local function outputInt(stack)
	io.write(readNextByte(stack))
	readNext(stack)
end 

local function outputChar(stack)
	io.write(string.char(readNextByte(stack)))
	readNext(stack)
end 

local function outputInt2(stack)
	io.write(readByte(stack, readAddress(stack)))
	readNext(stack)
end 

local function outputChar2(stack)
	io.write(string.char(readByte(stack, readAddress(stack))))
	readNext(stack)
end

local function ADD8(a, b)
	local sum = a + b 
	local sum8 = sum % 256
	local carry = (sum > 255) and 1 or 0
	return sum8, carry
end

local function SUB8(a, b)
	local diff = a - b 
	local borrow = 0
	if (diff < 0) then 
		diff = 256 - diff 
		borrow = 1
	end 
	return diff, borrow
end 

local function performADD(stack)
	local addr = readAddress(stack)
	local sum, carry = ADD8(readByte(stack, addr), readNextByte(stack))
	writeByte(stack, addr, sum)
	readNext(stack)
end 

local function performSUB(stack)
	local addr = readAddress(stack)
	local diff, borrow = SUB8(readByte(stack, addr), readNextByte(stack))
	writeByte(stack, addr, diff) 
	readNext(stack)
end 

local function performADD2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	local sum, carry = ADD8(readByte(stack, addr), readByte(stack, addr2))
	writeByte(stack, addr, sum)
	readNext(stack)
end

local function performSUB2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	local diff, borrow = SUB8(readByte(stack, addr), readByte(stack, addr2))
	writeByte(stack, addr, diff) 
	readNext(stack)
end

local function performIF(stack)
	local addr = readAddress(stack)
	local cByte = readByte(stack, addr)
	if(cByte and cByte > 0) then 
	    performJump(stack)
	else 
		local skippedAddr = readAddress(stack)
		performJump(stack)
	end 
end 

local function performIFSET(stack)
	local addr = readAddress(stack) 
	local moveAddr = readAddress(stack)
	local cByte = readByte(stack, addr)
	if(cByte and cByte > 0) then 
		passTo(stack, moveAddr, readAddress(stack))
	else 
		local skippedAddr = readAddress(stack)
		passTo(stack, moveAddr, readAddress(stack))
	end 
	readNext(stack)
end

local function performIFBYTE(stack)
	local addr = readAddress(stack)
	local moveAddr = readAddress(stack)
	local cByte = readByte(stack, addr)
	if(cByte and cByte > 0) then 
		writeByte(stack, moveAddr, readNextByte(stack))
	else 
		local skippedByte = readNextByte(stack)
		writeByte(stack, moveAddr, readNextByte(stack))
	end 
	readNext(stack)
end

local function readNumber(stack)
	writeByte(stack, readAddress(stack), tonumber(io.read()))
	readNext(stack)
end 

local function readCharacter(stack)
	writeByte(stack, readAddress(stack), string.byte((io.read() or string.char(0)):sub(1, 1)))
	readNext(stack)
end 

local function readHex(stack)
	writeByte(stack, readAddress(stack), hex2int(io.read():sub(1, 2) or "00"))
	readNext(stack)
end

local function performComp(stack, addr, addr2, b, comp)
	print("Call:", "performComp", "addr = "..addr, "addr2 = "..addr2, "b = "..b, "comp = "..comp)
	local a = readByte(stack, addr2)
	if(comp == "eq") then 
		writeByte(stack, addr, (a == b) and 1 or 0)
	elseif(comp == "ne") then 
		writeByte(stack, addr, (a ~= b) and 1 or 0)
	elseif(comp == "ge") then 
		writeByte(stack, addr, (a >= b) and 1 or 0)
	elseif(comp == "le") then 
		writeByte(stack, addr, (a <= b) and 1 or 0)
	elseif(comp == "gt") then 
		writeByte(stack, addr, (a > b) and 1 or 0)
	elseif(comp == "lt") then 
		writeByte(stack, addr, (a < b) and 1 or 0)
	end 
end 

local function performEQ(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readNextByte(stack), "eq")
	readNext(stack)
end 

local function performNE(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readNextByte(stack), "ne")
	readNext(stack)
end 

local function performGE(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readNextByte(stack), "ge")
	readNext(stack)
end 

local function performLE(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readNextByte(stack), "le")
	readNext(stack)
end 

local function performGT(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readNextByte(stack), "gt")
	readNext(stack)
end 

local function performLT(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readNextByte(stack), "lt")
	readNext(stack)
end 

local function performEQ2(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readByte(stack, readAddress(stack)), "eq")
	readNext(stack)
end 

local function performNE2(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readByte(stack, readAddress(stack)), "ne")
	readNext(stack)
end 

local function performGE2(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readByte(stack, readAddress(stack)), "ge")
	readNext(stack)
end 

local function performLE2(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readByte(stack, readAddress(stack)), "le")
	readNext(stack)
end 

local function performGT2(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readByte(stack, readAddress(stack)), "gt")
	readNext(stack)
end 

local function performLT2(stack)
	performComp(stack, readAddress(stack), readAddress(stack), readByte(stack, readAddress(stack)), "lt")
	readNext(stack)
end

local function performPush(stack)
	writeByte(stack, #stack + 1, readNextByte(stack))
	readNext(stack)
end 

local function performPush2(stack)
	writeByte(stack, #stack + 1, readByte(stack, readAddress(stack)))
	readNext(stack)
end 

local function performPop(stack)
	stack[#stack] = nil 
	readNext(stack)
end 

local function performPop2(stack)
	writeByte(stack, readAddress(stack), readByte(#stack))
	performPop(stack)
end

local instr = {
	[0x00] = exitProgram,
	[0x01] = performLoad,
	[0x02] = performPass,
	[0x03] = performSwap,
	[0x04] = performJump,
	[0x05] = outputInt,
	[0x06] = outputChar,
	[0x07] = outputInt2,
	[0x08] = outputChar2,
	[0x0A] = readNumber, 
	[0x0B] = readCharacter,
	[0x0C] = readHex,
		
	[0x11] = performAND,
	[0x12] = performOR,
	[0x13] = performXOR,
	[0x14] = performNOT,
	[0x15] = performLSHIFT,
	[0x16] = performRSHIFT,
	[0x17] = performROL, 
	[0x18] = performROR,
	
	[0x21] = performAND2,
	[0x22] = performOR2,
	[0x23] = performXOR2,
	[0x24] = performNOT2,
	[0x25] = performLSHIFT2,
	[0x26] = performRSHIFT2,
	[0x27] = performROL2, 
	[0x28] = performROR2,
	
	[0x31] = performADD,
	[0x32] = performSUB,
	
	[0x41] = performADD2,
	[0x42] = performSUB2,
	
	[0x51] = performIF,
	[0x52] = performIFBYTE,
	[0x53] = performIFSET,
	
	[0x61] = performEQ,
	[0x62] = performNE,
	[0x63] = performGT,
	[0x64] = performLT,
	[0x65] = performGE,
	[0x66] = performLE,
	
	[0x71] = performEQ2,
	[0x72] = performNE2,
	[0x73] = performGT2,
	[0x74] = performLT2,
	[0x75] = performGE2,
	[0x76] = performLE2,
	
	[0x91] = performPush,
	[0x92] = performPop,
	[0x93] = performPush2,
	[0x94] = performPop2
}

local function executeStack(stack)
	stack.pointer = 1
	while(not stack.exit and stack.pointer <= #stack) do 
		local val = readCurrentByte(stack)
		local current = instr[val]
		if(current) then 
			current(stack)
		else 
			readNext(stack)
		end
	end
end
	

return function (program)
	print(program)
	local STACK = {
		A = 0, B = 0, C = 0, D = 0, 
		E = 0, F = 0, G = 0, H = 0,
		
	}
	
	STACK.out = ""
	-- parse 
	if parseProgram(program, STACK) then 
		executeStack(STACK)
	else 
		print("Compile Error")
	end
end
	