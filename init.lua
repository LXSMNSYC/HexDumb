--[[
	Keys:
	- F0 = Register A 
	- F1 = Register B 
	- F2 = Register C 
	- F3 = Register D 
	- F4 = Register E
	- F5 = Register F 
	- F6 = Register G
	- F7 = Register H
	- F8 = Top Stack
	- F9 = Push to Top Stack
	- FA = Next Byte
	- FB = Previous Byte 
	- FC = Current Stack Position
	- FD = Specific Byte Address 
	- FE = Specific Short Address
	
	Instructions:
		- Utilities
		- 00 											- Exit
		- 01 [key] (byte (byte)) [byte]					- Load to [byte] to [key]
		- 02 [key] (byte (byte)) [key] (byte (byte))	- Pass to [Stack Position]
		- 03 [key] (byte (byte)) [key] (byte (byte))	- Swap Values
		- 04 [key] (byte (byte))						- Jump to
		- 05 [byte]										- Output as integer 
		- 06 [byte]										- Output as char 
		- 07 [key] (byte, (byte))						- Output as integer from addr 
		- 08 [key] (byte, (byte))						- Output as char
		- 0A [key] (byte, (byte))						- Read input as number 
		- 0B [key] (byte, (byte))						- Read input as character 
		- 0C [key] (byte, (byte))						- Read input as hex
		
		- Bitwise
		- 11 [key] (byte (byte)) [byte]					- AND
		- 12 [key] (byte (byte)) [byte]					- OR
		- 13 [key] (byte (byte)) [byte]					- XOR 
		- 14 [key] (byte (byte))						- NOT
		- 15 [key] (byte (byte)) [byte]					- RSHIFT 
		- 16 [key] (byte (byte)) [byte]					- LSHIFT 
		- 17 [key] (byte (byte)) [byte]					- ROL
		- 18 [key] (byte (byte)) [byte]					- ROR 
		
		- Bitwise key by key 
		- 21 [key] (byte (byte)) [key] (byte (byte))	- AND
		- 22 [key] (byte (byte)) [key] (byte (byte))	- OR
		- 23 [key] (byte (byte)) [key] (byte (byte))	- XOR 
		- 24 [key] (byte (byte))						- NOT
		- 25 [key] (byte (byte)) [key] (byte (byte))	- RSHIFT 
		- 26 [key] (byte (byte)) [key] (byte (byte))	- LSHIFT 
		- 27 [key] (byte (byte)) [key] (byte (byte))	- ROL
		- 28 [key] (byte (byte)) [key] (byte (byte))	- ROR 
		
		- Arithmetic
		- 31 [key] (byte (byte)) [byte]					- ADD
		- 32 [key] (byte (byte)) [byte]					- SUB
		
		- Arithmetic Key to Key
		- 41 [key] (byte (byte)) [key] (byte (byte))	- ADD 
		- 42 [key] (byte (byte)) [key] (byte (byte))	- SUB
		
		- Conditional
		- 51 [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) - IF (key) JMP (key) ELSE JMP (key)
		- 52 [key] (byte (byte)) [key] (byte (byte)) [byte] [byte]		 - IF (key) SET (key) = [byte] else [byte]
		- 53 [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) [key] (byte (byte)) 
					- IF (key) SET (key) = (key) else (key)
		
		
	
]]
-- sub-byte bitwise
local AND4 = {
[0]=0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1,
	0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2,
	0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3,
	0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x4, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x4, 0x4,
	0x0, 0x1, 0x0, 0x1, 0x4, 0x5, 0x4, 0x5, 0x0, 0x1, 0x0, 0x1, 0x4, 0x5, 0x4, 0x5,
	0x0, 0x0, 0x2, 0x2, 0x4, 0x4, 0x6, 0x6, 0x0, 0x0, 0x2, 0x2, 0x4, 0x4, 0x6, 0x6,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x8, 0x9, 0x8, 0x9, 0x8, 0x9, 0x8, 0x9,
	0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x8, 0x8, 0xa, 0xa, 0x8, 0x8, 0xa, 0xa,
	0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3, 0x8, 0x9, 0xa, 0xb, 0x8, 0x9, 0xa, 0xb,
	0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x4, 0x4, 0x8, 0x8, 0x8, 0x8, 0xc, 0xc, 0xc, 0xc,
	0x0, 0x1, 0x0, 0x1, 0x4, 0x5, 0x4, 0x5, 0x8, 0x9, 0x8, 0x9, 0xc, 0xd, 0xc, 0xd,
	0x0, 0x0, 0x2, 0x2, 0x4, 0x4, 0x6, 0x6, 0x8, 0x8, 0xa, 0xa, 0xc, 0xc, 0xe, 0xe,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
}
local OR4 = {
[0]=0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x1, 0x1, 0x3, 0x3, 0x5, 0x5, 0x7, 0x7, 0x9, 0x9, 0xb, 0xb, 0xd, 0xd, 0xf, 0xf,
	0x2, 0x3, 0x2, 0x3, 0x6, 0x7, 0x6, 0x7, 0xa, 0xb, 0xa, 0xb, 0xe, 0xf, 0xe, 0xf,
	0x3, 0x3, 0x3, 0x3, 0x7, 0x7, 0x7, 0x7, 0xb, 0xb, 0xb, 0xb, 0xf, 0xf, 0xf, 0xf,
	0x4, 0x5, 0x6, 0x7, 0x4, 0x5, 0x6, 0x7, 0xc, 0xd, 0xe, 0xf, 0xc, 0xd, 0xe, 0xf,
	0x5, 0x5, 0x7, 0x7, 0x5, 0x5, 0x7, 0x7, 0xd, 0xd, 0xf, 0xf, 0xd, 0xd, 0xf, 0xf,
	0x6, 0x7, 0x6, 0x7, 0x6, 0x7, 0x6, 0x7, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x9, 0x9, 0xb, 0xb, 0xd, 0xd, 0xf, 0xf, 0x9, 0x9, 0xb, 0xb, 0xd, 0xd, 0xf, 0xf,
	0xa, 0xb, 0xa, 0xb, 0xe, 0xf, 0xe, 0xf, 0xa, 0xb, 0xa, 0xb, 0xe, 0xf, 0xe, 0xf,
	0xb, 0xb, 0xb, 0xb, 0xf, 0xf, 0xf, 0xf, 0xb, 0xb, 0xb, 0xb, 0xf, 0xf, 0xf, 0xf,
	0xc, 0xd, 0xe, 0xf, 0xc, 0xd, 0xe, 0xf, 0xc, 0xd, 0xe, 0xf, 0xc, 0xd, 0xe, 0xf,
	0xd, 0xd, 0xf, 0xf, 0xd, 0xd, 0xf, 0xf, 0xd, 0xd, 0xf, 0xf, 0xd, 0xd, 0xf, 0xf,
	0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf, 0xe, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
}
local XOR4 = {
[0]=0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6, 0x9, 0x8, 0xb, 0xa, 0xd, 0xc, 0xf, 0xe,
	0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5, 0xa, 0xb, 0x8, 0x9, 0xe, 0xf, 0xc, 0xd,
	0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4, 0xb, 0xa, 0x9, 0x8, 0xf, 0xe, 0xd, 0xc,
	0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3, 0xc, 0xd, 0xe, 0xf, 0x8, 0x9, 0xa, 0xb,
	0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2, 0xd, 0xc, 0xf, 0xe, 0x9, 0x8, 0xb, 0xa,
	0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1, 0xe, 0xf, 0xc, 0xd, 0xa, 0xb, 0x8, 0x9,
	0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0, 0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9, 0x8,
	0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
	0x9, 0x8, 0xb, 0xa, 0xd, 0xc, 0xf, 0xe, 0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6,
	0xa, 0xb, 0x8, 0x9, 0xe, 0xf, 0xc, 0xd, 0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5,
	0xb, 0xa, 0x9, 0x8, 0xf, 0xe, 0xd, 0xc, 0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4,
	0xc, 0xd, 0xe, 0xf, 0x8, 0x9, 0xa, 0xb, 0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3,
	0xd, 0xc, 0xf, 0xe, 0x9, 0x8, 0xb, 0xa, 0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2,
	0xe, 0xf, 0xc, 0xd, 0xa, 0xb, 0x8, 0x9, 0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1,
	0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0,
}
local RIGHT = {
[0]=0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
}
local LEFT = {
[0]=0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
}

local floor = math.floor 


--[[
	Memoization
]]--
local mem_AND = {}
local mem_OR = {}
local mem_XOR = {}
local mem_LSHIFT = {}
local mem_RSHIFT = {}
local mem_ROL = {}
local mem_ROR = {}

local function bw8(a, b, op, mem)
	local key = a*256 + b
	local result = mem[key] or mem[b*256 + a]
	if(not result) then 
		local la, ra = LEFT[a], RIGHT[a]
		local lb, rb = LEFT[b], RIGHT[b]
		local lr, rr = op[la*16 + lb], op[ra*16 + rb]
		
		result = lr*16 + rr
		
		mem[key] = result 
	end 
	return result
end 

local function AND(a, b)
	return bw8(a, b, AND4, mem_AND)
end

local function OR(a, b)
	return bw8(a, b, OR4, mem_OR)
end 

local function XOR(a, b)
	return bw8(a, b, XOR4, mem_XOR)
end 

local function NOT(a)
	return 255 - a
end

local function LSHIFT(a, b)
	if(b >= 8) then 
		return 0
	end 
	local key = a*256 + b 
	local result = mem_LSHIFT[key] or mem_LSHIFT[b*256 + a]
	if(not result) then 
		result = a*(2^b)
		mem_LSHIFT[key] = result
	end
	return result 
end

local function RSHIFT(a, b)
	if(b >= 8) then 
		return 0
	end 
	local key = a*256 + b 
	local result = mem_RSHIFT[key] or mem_RSHIFT[b*256 + a]
	if(not result) then 
		result = floor(a/(2^b))
		mem_RSHIFT[key] = result
	end
	return result 
end

local function ROL(a, b)
	b = b % 8
	local key = a*256 + b 
	local result = mem_ROL[key] or mem_ROL[b*256 + a]
	if(not result) then 
		result = OR(LSHIFT(a, b), RSHIFT(a, 8 - b))
		mem_ROL[key] = result
	end
	return result 
end 

local function ROR(a, b)
	b = b % 8
	local key = a*256 + b 
	local result = mem_ROL[key] or mem_ROL[b*256 + a]
	if(not result) then 
		result = OR(RSHIFT(a, b), LSHIFT(a, 8 - b))
		mem_ROL[key] = result
	end
	return result 
end 

local len = string.len 

local hex = "0123456789ABCDEF"
local COMMENT = "#"

local function hex2int(a, b)
	a = string.find(hex, a)
	b = string.find(hex, b)
	return (a - 1)*16 + (b - 1)
end 


local function parseProgram(program, output)
	local count = 1
	local c = 1
	local length = len(program)
	local ignore = false
	
	program = string.upper(program)
	
	local acc = ""
	while(c <= length) do 
		local character = string.sub(program, c, c)
		if(character == COMMENT) then 
			ignore = not ignore
		end
		if(not ignore) then 
			if(string.find(hex, character)) then 
				if(acc ~= "") then 
					output[count] = hex2int(acc, character)
					count = count + 1
					acc = ""
				else 
					acc = character
				end 
			elseif (acc ~= "") then 
				output.exit = true 
				output.out = "Compile error"
			end
		end
		c = c + 1
	end 
end 

--[[
	Instructions
]]--
local registers = {
	[0xF0] = "A",
	[0xF1] = "B",
	[0xF2] = "C",
	[0xF3] = "D",
	[0xF4] = "E",
	[0xF5] = "F",
	[0xF6] = "G",
	[0xF7] = "H"
}
local function exitProgram(stack)
	stack.exit = true 
end 

local function boundRegister(r)
	if(type(r) == "number" and r < 0) then 
		return 0
	end 
	return r
end

local function loadByte(stack, r1, value)
	r1 = boundRegister(r1)
	stack[r1] = value
end 

local function passTo(stack, r1, r2)
	r1 = boundRegister(r1)
	r2 = boundRegister(r2)
	stack[r2] = stack[r1]
end 

local function swap(stack, r1, r2)
	r1 = boundRegister(r1)
	r2 = boundRegister(r2)
	stack[r1], stack[r2] = stack[r2], stack[r1]
end 

local function jump(stack, r1)
	stack.pointer = r1
end

local function readNext(stack)
	stack.pointer = stack.pointer + 1
end

local function readByte(stack)
	return stack[stack.pointer] or 0
end

local function readNextByte(stack)
	readNext(stack)
	return readByte(stack)
end

local function readAddress(stack)
	local current = stack.pointer
	local key = readNextByte(stack)
	local register = registers[key]
	if(register) then 
		return register 
	elseif(key == 0xF8) then 
		return #stack 
	elseif(key == 0xF9) then 
		return #stack + 1
	elseif(key == 0xFA) then 
		return current + 1
	elseif(key == 0xFB) then 
		return current - 1
	elseif(key == 0xFC) then 
		return current 
	elseif(key == 0xFD) then 
		return readNextByte(stack)
	elseif(key == 0xFE) then 
		return readNextByte(stack)*0x100 + readNextByte(stack)
	else 
		exitProgram(stack)
	end 
end
	
local function performLoad(stack)
	loadByte(stack, readAddress(stack), readNextByte(stack))
	readNext(stack)
end

local function performPass(stack)
	passTo(stack, readAddress(stack), readAddress(stack))
	readNext(stack)
end

local function performSwap(stack)
	swap(stack, readAddress(stack), readAddress(stack))
	readNext(stack)
end 

local function performJump(stack)
	local addr = readAddress(stack)
	if(type(addr) == "string") then 
		jump(stack, stack[addr])
	else 
		jump(stack, addr)
	end 
end

local function performAND(stack)
	local addr = readAddress(stack)
	stack[addr] = AND(stack[addr], readNextByte(stack))
	readNext(stack)
end 

local function performOR(stack)
	local addr = readAddress(stack)
	stack[addr] = OR(stack[addr], readNextByte(stack))
	readNext(stack)
end

local function performXOR(stack)
	local addr = readAddress(stack)
	stack[addr] = XOR(stack[addr], readNextByte(stack))
	readNext(stack)
end

local function performNOT(stack)
	local addr = readAddress(stack)
	stack[addr] = NOT(stack[addr])
	readNext(stack)
end

local function performLSHIFT(stack)
	local addr = readAddress(stack)
	stack[addr] = LSHIFT(stack[addr], readNextByte(stack))
	readNext(stack)
end

local function performRSHIFT(stack)
	local addr = readAddress(stack)
	stack[addr] = RSHIFT(stack[addr], readNextByte(stack))
	readNext(stack)
end

local function performROL(stack)
	local addr = readAddress(stack)
	stack[addr] = ROL(stack[addr], readNextByte(stack))
	readNext(stack)
end

local function performROR(stack)
	local addr = readAddress(stack)
	stack[addr] = ROR(stack[addr], readNextByte(stack))
	readNext(stack)
end

local function performAND2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	stack[addr] = AND(stack[addr], stack[addr2])
	readNext(stack)
end 

local function performOR2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	stack[addr] = OR(stack[addr], stack[addr2])
	readNext(stack)
end

local function performXOR2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	stack[addr] = XOR(stack[addr], stack[addr2])
	readNext(stack)
end

local function performNOT2(stack)
	local addr = readAddress(stack)
	stack[addr] = NOT(stack[addr])
	readNext(stack)
end

local function performLSHIFT2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	stack[addr] = LSHIFT(stack[addr], stack[addr2])
	readNext(stack)
end

local function performRSHIFT2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	stack[addr] = RSHIFT(stack[addr], stack[addr2])
	readNext(stack)
end

local function performROL2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	stack[addr] = ROL(stack[addr], stack[addr2])
	readNext(stack)
end

local function performROR2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	stack[addr] = ROR(stack[addr], stack[addr2])
	readNext(stack)
end

local function outputInt(stack)
	io.write(readNextByte(stack))
	readNext(stack)
end 

local function outputChar(stack)
	io.write(string.char(readNextByte(stack)))
	readNext(stack)
end 

local function outputInt2(stack)
	io.write(stack[readAddress(stack)] or 0)
end 

local function outputChar2(stack)
	io.write(string.char(stack[readAddress(stack)] or 0))
end

local function performADD(stack)
	local addr = readAddress(stack)
	stack[addr] = (stack[addr] + readNextByte(stack)) % 256
	readNext(stack)
end 

local function performSUB(stack)
	local addr = readAddress(stack)
	local diff = (stack[addr] - readNextByte(stack))
	while(diff < 0) do 
		diff = 256 - diff 
	end 
	stack[addr] = diff 
	readNext(stack)
end 

local function performADD2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	stack[addr] = (stack[addr] + stack[addr2]) % 256
	readNext(stack)
end

local function performSUB2(stack)
	local addr = readAddress(stack)
	local addr2 = readAddress(stack)
	local diff = (stack[addr] - stack[addr2])
	while(diff < 0) do 
		diff = 256 - diff 
	end 
	stack[addr] = diff 
	readNext(stack)
end

local function performIF(stack)
	local addr = readAddress(stack)
	if(stack[addr] and stack[addr] > 0) then 
	    performJump(stack)
	else 
		local skippedAddr = readAddress(stack)
		performJump(stack)
	end 
end 

local function performIFSET(stack)
	local addr = readAddress(stack) 
	local moveAddr = readAddress(stack)
	if(stack[addr] and stack[addr] > 0) then
		passTo(stack, moveAddr, readAddress(stack))
	else 
		local skippedAddr = readAddress(stack)
		passTo(stack, moveAddr, readAddress(stack))
	end 
	readNext(stack)
end

local function performIFBYTE(stack)
	local addr = readAddress(stack)
	local moveAddr = readAddress(stack)
	if(stack[addr] and stack[addr] > 0) then 
		loadByte(stack, moveAddr, readNextByte(stack))
	else 
		local skippedByte = readNextByte(stack)
		loadByte(stack, moveAddr, readNextByte(stack))
	end 
	readNext(stack)
end

local function readNumber(stack)
	loadByte(stack, readAddress(stack), tonumber(io.read()))
end 

local function readCharacter(stack)
	loadByte(stack, readAddress(stack), string.byte((io.read() or string.char(0)):sub(1, 1)))
end 

local function readHex(stack)
	loadByte(stack, readAddress(stack), hex2int(io.read()))
end

local instr = {
	[0x00] = exitProgram,
	[0x01] = performLoad,
	[0x02] = performPass,
	[0x03] = performSwap,
	[0x04] = performJump,
	[0x05] = outputInt,
	[0x06] = outputChar,
	[0x07] = outputInt2,
	[0x08] = outputChar2,
	[0x0A] = readNumber, 
	[0x0B] = readCharacter,
	[0x0C] = readHex,
		
	[0x11] = performAND,
	[0x12] = performOR,
	[0x13] = performXOR,
	[0x14] = performNOT,
	[0x15] = performLSHIFT,
	[0x16] = performRSHIFT,
	[0x17] = performROL, 
	[0x18] = performROR,
	
	[0x21] = performAND2,
	[0x22] = performOR2,
	[0x23] = performXOR2,
	[0x24] = performNOT2,
	[0x25] = performLSHIFT2,
	[0x26] = performRSHIFT2,
	[0x27] = performROL2, 
	[0x28] = performROR2,
	
	[0x31] = performADD,
	[0x32] = performSUB,
	
	[0x41] = performADD2,
	[0x42] = performSUB2,
	
	[0x51] = performIF,
	[0x52] = performIFBYTE,
	[0x53] = performIFSET,
}

local function executeStack(stack)
	stack.pointer = 1
	while(not stack.exit and stack.pointer <= #stack) do 
		local val = stack[stack.pointer]
		local current = instr[val]
		if(current) then 
			current(stack)
		else 
			readNext(stack)
		end
	end
end
	

return function (program)
	local STACK = {
		A = 0, B = 0, C = 0, D = 0, 
		E = 0, F=  0, G = 0, H = 0
	}
	STACK.out = ""
	
	-- parse 
	parseProgram(program, STACK)
	executeStack(STACK)
end
	